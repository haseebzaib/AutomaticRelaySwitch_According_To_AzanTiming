/*
 * Copyright (c) 2016 Intel Corporation
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <stdio.h>
#include <zephyr/kernel.h>
#include <zephyr/drivers/i2c.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/drivers/uart.h>
#include "RTCmcp7940.h"
#include "ssd1306_fonts.h"
#include "ssd1306.h"
#include "xmodem.h"
#include "sys_flash.h"
#include "pray2_reader.h"
#include "sd_pray2_io.h"
#include <stdbool.h>
#include <stddef.h>
#include <string.h>
#include <ctype.h>
#include <stdint.h>
#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(app);

extern void run_pray2_tests(void);

/* 1000 msec = 1 sec */
#define SLEEP_TIME_MS 1000

/* The devicetree node identifier for the "led0" alias. */
#define LED0_NODE DT_ALIAS(led0)
/* The devicetree node identifier for the "led0" alias. */
#define LED1_NODE DT_ALIAS(led1)

/* The devicetree node identifier for the "led0" alias. */
#define button1_NODE DT_ALIAS(sw0)
/* The devicetree node identifier for the "led0" alias. */
#define button2_NODE DT_ALIAS(sw1)

/*
 * A build error on this line means your board is unsupported.
 * See the sample documentation for information on how to fix this.
 */
static const struct gpio_dt_spec led = GPIO_DT_SPEC_GET(LED0_NODE, gpios);
static const struct gpio_dt_spec relay = GPIO_DT_SPEC_GET(LED1_NODE, gpios);

static const struct gpio_dt_spec auto_btn = GPIO_DT_SPEC_GET(button1_NODE, gpios);
static const struct gpio_dt_spec manual_btn = GPIO_DT_SPEC_GET(button2_NODE, gpios);

const struct device *uart = DEVICE_DT_GET(DT_NODELABEL(uart0));

const struct device *RTC_MCP;
const struct device *SSD1306;

char buffer[50];
char timebuff[50];
char datebuff[50];

char TxBuffer[100];
char RxBuffer[100];
uint8_t DataBuffer[4 * 1024];
uint8_t DataBuffer_HEX[10];
uint16_t DataBufferTotalSize = sizeof(DataBuffer);
size_t DataBufferTotalSize_ = 0;
char *RxBufferP;
uint32_t RxBufferCounter = 0;
uint32_t RxBufferSize = 0;
uint8_t data = 1;

K_MSGQ_DEFINE(uart_msgq, 1, 10, 4);

#define TIME_STR_LEN 9 /* "HH:MM:SS" + '\0' */
#define DATE_STR_LEN 9 /* "DD/MM/YY" + '\0' */

pray2_sched_t sched;

uint8_t trigger_relay = 0;
uint32_t relay_start_time = 0;
uint32_t relay_timeout_set = 5000;

uint8_t auto_relay_once = 0;
uint8_t manual_auto_config = 0; // manual = 0 auto = 1

const unsigned char startup_image_[] = {
	// 'WhatsApp Image 2025-04-28 at 16, 128x64px
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0x80, 0x00, 0x00,
	0x00, 0x03, 0xff, 0xff, 0xfe, 0x03, 0xff, 0xff, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x00, 0x00,
	0x00, 0x03, 0xff, 0xff, 0xff, 0x07, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x3f, 0xff, 0xfc, 0x00, 0x00,
	0x00, 0x03, 0xff, 0xff, 0xff, 0x07, 0xff, 0xff, 0xfc, 0x00, 0x00, 0xff, 0xff, 0xfe, 0x00, 0x00,
	0x00, 0x03, 0xff, 0xff, 0xff, 0x07, 0xff, 0xff, 0xff, 0x00, 0x01, 0xff, 0xff, 0xff, 0x80, 0x00,
	0x00, 0x03, 0xff, 0xff, 0xff, 0x07, 0xff, 0xff, 0xff, 0x80, 0x03, 0xff, 0xff, 0xff, 0xc0, 0x00,
	0x00, 0x03, 0xff, 0xff, 0xff, 0x07, 0xff, 0xff, 0xff, 0xc0, 0x07, 0xff, 0xff, 0xff, 0xc0, 0x00,
	0x00, 0x03, 0xff, 0xff, 0xff, 0x07, 0xff, 0xff, 0xff, 0xe0, 0x0f, 0xff, 0xff, 0xff, 0xc0, 0x00,
	0x00, 0x03, 0xff, 0xff, 0xff, 0x07, 0xff, 0xff, 0xff, 0xe0, 0x0f, 0xff, 0xff, 0xff, 0x80, 0x00,
	0x00, 0x03, 0xff, 0xff, 0xff, 0x07, 0xff, 0xff, 0xff, 0xf0, 0x1f, 0xff, 0xe3, 0xff, 0x00, 0x00,
	0x00, 0x03, 0xff, 0xc0, 0x00, 0x07, 0xff, 0xff, 0xff, 0xf0, 0x1f, 0xff, 0x00, 0x7e, 0x00, 0x00,
	0x00, 0x03, 0xff, 0x80, 0x00, 0x07, 0xff, 0x00, 0xff, 0xf0, 0x3f, 0xfe, 0x00, 0x3c, 0x00, 0x00,
	0x00, 0x03, 0xff, 0x80, 0x00, 0x07, 0xff, 0x80, 0x7f, 0xf8, 0x3f, 0xfc, 0x00, 0x18, 0x00, 0x00,
	0x00, 0x03, 0xff, 0x80, 0x00, 0x07, 0xff, 0x80, 0x7f, 0xf8, 0x3f, 0xf8, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x03, 0xff, 0x80, 0x00, 0x07, 0xff, 0x80, 0x7f, 0xf8, 0x3f, 0xf8, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x03, 0xff, 0xff, 0xfe, 0x07, 0xff, 0x80, 0x7f, 0xf8, 0x7f, 0xf8, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x03, 0xff, 0xff, 0xfe, 0x07, 0xff, 0x80, 0x7f, 0xf8, 0x7f, 0xf0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x03, 0xff, 0xff, 0xfe, 0x07, 0xff, 0x80, 0x7f, 0xf0, 0x7f, 0xc0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x03, 0xff, 0xff, 0xfe, 0x07, 0xff, 0x81, 0xff, 0xf0, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x03, 0xff, 0xff, 0xfe, 0x07, 0xff, 0xff, 0xff, 0xf0, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x03, 0xff, 0xff, 0xfe, 0x07, 0xff, 0xff, 0xff, 0xf0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x03, 0xff, 0xff, 0xfe, 0x07, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x03, 0xff, 0xff, 0xfe, 0x07, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x03, 0xff, 0x80, 0x00, 0x07, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x03, 0xff, 0x80, 0x00, 0x07, 0xff, 0xff, 0xff, 0x80, 0x00, 0x80, 0x00, 0x18, 0x00, 0x00,
	0x00, 0x03, 0xff, 0x80, 0x00, 0x07, 0xff, 0xff, 0xff, 0x00, 0x07, 0x80, 0x00, 0x3c, 0x00, 0x00,
	0x00, 0x03, 0xff, 0x80, 0x00, 0x07, 0xff, 0xff, 0xfc, 0x00, 0x1f, 0x81, 0x00, 0xfe, 0x00, 0x00,
	0x00, 0x03, 0xff, 0x80, 0x00, 0x07, 0xff, 0xff, 0xf0, 0x00, 0x1f, 0x87, 0xe3, 0xff, 0x00, 0x00,
	0x00, 0x03, 0xff, 0xff, 0xff, 0x07, 0xff, 0x80, 0x00, 0x00, 0x0f, 0x1f, 0xff, 0xff, 0x80, 0x00,
	0x00, 0x03, 0xff, 0xff, 0xff, 0x07, 0xff, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xc0, 0x00,
	0x00, 0x03, 0xff, 0xff, 0xff, 0x07, 0xff, 0x80, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xc0, 0x00,
	0x00, 0x03, 0xff, 0xff, 0xff, 0x07, 0xff, 0x80, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0x80, 0x00,
	0x00, 0x03, 0xff, 0xff, 0xff, 0x07, 0xff, 0x80, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0x00, 0x00,
	0x00, 0x03, 0xff, 0xff, 0xff, 0x07, 0xff, 0x80, 0x00, 0x00, 0x00, 0xff, 0xff, 0xfe, 0x00, 0x00,
	0x00, 0x03, 0xff, 0xff, 0xff, 0x07, 0xff, 0x80, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xfc, 0x00, 0x00,
	0x00, 0x03, 0xff, 0xff, 0xff, 0x07, 0xff, 0x80, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x00, 0x00,
	0x00, 0x03, 0xff, 0xff, 0xff, 0x07, 0xff, 0x80, 0x00, 0x00, 0x00, 0x01, 0xff, 0x80, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

void ledfasttoggle(uint8_t toggling)
{
	for (int i = 0; i < toggling; i++)
	{

		gpio_pin_toggle_dt(&led);

		k_msleep(10);
	}
}

void ledfasttoggle_with_speed(uint8_t toggling, uint16_t togglingspeed)
{
	for (int i = 0; i < toggling; i++)
	{

		gpio_pin_toggle_dt(&led);

		k_msleep(togglingspeed);
	}
}

void print_uart(char *buf)
{
	int msg_len = strlen(buf);

	for (int i = 0; i < msg_len; i++)
	{
		uart_poll_out(uart, buf[i]);
	}
}

void print_dataBuffer(uint8_t *buf)
{
	for (int i = 0; i < 4096; i++)
	{
		uart_poll_out(uart, buf[i]);
	}
}

void handle_new_pray2_file(void)
{
	pray2_header_t H;
	pray2_status_t st = pray2_validate_and_parse_no_crc(DataBuffer, DataBufferTotalSize, &H);
	if (st != PRAY2_OK)
	{
		print_uart("\r\nError in bin file\r\n");
		return;
	}

	// If one-shot flag is set, set RTC and then clear the flag in the stored blob
	if (H.flags & PRAY2_FLAG_RTC_ONE_SHOT)
	{
		int hh, mm, ss, DD, MMh, YYYY;
		if (pray2_parse_rtc_ascii(H.rtc_ascii, &hh, &mm, &ss, &DD, &MMh, &YYYY))
		{
			sprintf(buffer, "%02d:%02d:%02d|%02d/%02d/%02d", hh, mm, ss, DD, MMh, YYYY % 100);
			print_uart(buffer);
			RTCmcp7940_set_datetime(RTC_MCP, buffer);

			// Clear the one-shot flag in the stored header byte (offset 14)
			DataBuffer[14] = (uint8_t)(DataBuffer[14] & ~(PRAY2_FLAG_RTC_ONE_SHOT));
			H.flags &= ~(PRAY2_FLAG_RTC_ONE_SHOT);
			print_uart("\r\nRTC set from file (one-shot). Flag cleared.\r\n");
		}
		else
		{
			print_uart("\r\nRTC parse failed; skipping RTC set.\r\n");
		}
	}
	else
	{
		print_uart("\r\nRTC one-shot flag not set; leaving RTC unchanged.\r\n");
	}

	// Read RTC back and init scheduler with the actual device time
	RTCmcp7940_get_datetime(RTC_MCP, buffer); // "HH:MM:SS|DD/MM/YY"
	bool ok = pray2_sched_init_from_ram(&sched, DataBuffer, DataBufferTotalSize, buffer);

	if (ok)
	{
		print_uart("\r\nPray2 Init success\r\n");
		int hh2, mm2, ss2, DD2, MM2, YYYY2;
		if (pray2_parse_rtc_ascii(buffer, &hh2, &mm2, &ss2, &DD2, &MM2, &YYYY2))
		{
			debug_print_month_any_year(DataBuffer, DataBufferTotalSize, MM2);
			// sys_flash_write(0, DataBuffer, sizeof(DataBuffer));
		}
	}
	else
	{
		print_uart("\r\nPray2 Init failed (date out of span or parse error)\r\n");
	}
}

void serial_cb(const struct device *dev, void *user_data)
{
	uint8_t c;

	if (!uart_irq_update(uart))
	{
		return;
	}

	if (!uart_irq_rx_ready(uart))
	{
		return;
	}

	/* read until FIFO empty */
	while (uart_fifo_read(uart, &c, 1) == 1)
	{
		RxBufferP[RxBufferCounter] = c;
		/* else: characters beyond buffer size are dropped */
		RxBufferCounter++;
		if (RxBufferCounter >= RxBufferSize)
		{
			//   RxBufferCounter = 0;
			k_msgq_put(&uart_msgq, &data, K_NO_WAIT);
		}
	}
}

static void APPuart_init()
{
	if (!device_is_ready(uart))
	{
		printk("UART device not ready\n");
		return;
	}
	uart_irq_callback_user_data_set(uart, serial_cb, NULL);
	uart_irq_rx_enable(uart);

	sprintf(TxBuffer, "System Started......\r\n");
	print_uart(TxBuffer);
	// K_MSEC
	// uart_rx_enable();
}

static uint8_t APPuart_rx(uint8_t *buf, uint16_t size, uint32_t timeout)
{
	// uart_rx_enable(uart,RxBuffer,5,SYS_FOREVER_MS);
	RxBufferCounter = 0;
	RxBufferP = buf;
	RxBufferSize = size;

	if (k_msgq_get(&uart_msgq, &data, K_MSEC(timeout)) == 0)
	{
		return 0;
	}

	return 0xFF;
}

static uint8_t APPuart_tx(uint8_t byte, uint32_t timeout)
{
	uart_poll_out(uart, byte);
	// k_msleep(timeout);

	return 0;
}

static void APPuart_process()
{
	APPuart_rx(RxBuffer, 1, 1000);
	// print_uart(RxBuffer);
	// print_uart("\n");

	// k_msleep(1000);

	if (RxBuffer[0] == 'f')
	{

		xmodem_receive(DataBuffer, APPuart_rx, APPuart_tx);
		print_uart("\r\n");
		print_uart("\r\n");
		//  for (int i = 0; i < 3968; i++) {
		// 	sprintf(DataBuffer_HEX,"%02x ",DataBuffer[i]);
		// 	print_uart(DataBuffer_HEX);
		// }

		sprintf(DataBuffer_HEX, "%ld ", DataBufferTotalSize);
		print_uart(DataBuffer_HEX);
		handle_new_pray2_file();
		RxBuffer[0] = '\0';

		char saved_path[128];
		int rc = sd_store_pray2_from_ram("/SD:", DataBuffer, DataBufferTotalSize,
										 saved_path, sizeof(saved_path));
		char msg[200];
		if (rc == 0)
		{
			snprintf(msg, sizeof(msg), "Saved PRAY2 to %s (%u bytes)\r\n",
					 saved_path, (unsigned)DataBufferTotalSize);
		}
		else if (rc == -EEXIST)
		{
			snprintf(msg, sizeof(msg),
					 "Error: multiple .bin files present on SD. Keep only one.\r\n");
		}
		else
		{
			snprintf(msg, sizeof(msg), "Save failed (rc=%d)\r\n", rc);
		}
		print_uart(msg);
	}
}

/* --- internal validators --- */
static bool valid_time_hms(const char *s, size_t len)
{
	if (len != 8)
		return false; /* HH:MM:SS */
	if (!isdigit((unsigned char)s[0]) || !isdigit((unsigned char)s[1]) ||
		s[2] != ':' ||
		!isdigit((unsigned char)s[3]) || !isdigit((unsigned char)s[4]) ||
		s[5] != ':' ||
		!isdigit((unsigned char)s[6]) || !isdigit((unsigned char)s[7]))
		return false;

	int H = (s[0] - '0') * 10 + (s[1] - '0');
	int M = (s[3] - '0') * 10 + (s[4] - '0');
	int S = (s[6] - '0') * 10 + (s[7] - '0');
	return (H >= 0 && H <= 23) && (M >= 0 && M <= 59) && (S >= 0 && S <= 59);
}

static bool valid_date_dmy(const char *s, size_t len)
{
	if (len != 8)
		return false; /* DD/MM/YY */
	if (!isdigit((unsigned char)s[0]) || !isdigit((unsigned char)s[1]) ||
		s[2] != '/' ||
		!isdigit((unsigned char)s[3]) || !isdigit((unsigned char)s[4]) ||
		s[5] != '/' ||
		!isdigit((unsigned char)s[6]) || !isdigit((unsigned char)s[7]))
		return false;

	int D = (s[0] - '0') * 10 + (s[1] - '0');
	int M = (s[3] - '0') * 10 + (s[4] - '0');
	int Y = (s[6] - '0') * 10 + (s[7] - '0'); /* 00..99 */
	(void)Y;								  /* keep it simple here; adjust to full year if you want */
	return (D >= 1 && D <= 31) && (M >= 1 && M <= 12);
}

/* --- main helper --- */
bool split_timestamp_HHMMSS_bar_DDMMYY(const char *in,
									   char *time_out, size_t time_out_sz,
									   char *date_out, size_t date_out_sz)
{
	if (!in || !time_out || !date_out)
		return false;
	if (time_out_sz < TIME_STR_LEN || date_out_sz < DATE_STR_LEN)
		return false;

	const char *bar = strchr(in, '|');
	if (!bar)
		return false;

	size_t tlen = (size_t)(bar - in);
	const char *date_ptr = bar + 1;
	size_t dlen = strlen(date_ptr);

	if (!valid_time_hms(in, tlen))
		return false;
	if (!valid_date_dmy(date_ptr, dlen))
		return false;

	memcpy(time_out, in, tlen);
	time_out[tlen] = '\0';

	memcpy(date_out, date_ptr, dlen);
	date_out[dlen] = '\0';

	return true;
}

char outputBuffersdcardprint[255];
void load_pray2_from_sd_and_init(void)
{
	char bin_path[128];
	int rc = sd_find_single_bin("/SD:", bin_path, sizeof(bin_path));
	if (rc)
	{
		sprintf(outputBuffersdcardprint, "No single .bin on SD (rc=%d)\r\n", rc);
		print_uart(outputBuffersdcardprint);

		ledfasttoggle_with_speed(10, 200);

		return;
	}

	sprintf(outputBuffersdcardprint, "\r\n%s\r\n", bin_path);

	print_uart(outputBuffersdcardprint);

	rc = sd_load_entire_file(bin_path, DataBuffer, sizeof(DataBuffer), &DataBufferTotalSize_);
	if (rc)
	{

		sprintf(outputBuffersdcardprint, "Read failed (rc=%d)\r\n", rc);
		print_uart(outputBuffersdcardprint);
		ledfasttoggle_with_speed(10, 200);
		return;
	}

	// Parse + handle one-shot inside your existing handler
	handle_new_pray2_file(); // this sets RTC if needed and clears DataBuffer[14]

	// Persist the cleared flag back to SD (so it remains cleared next boot)
	(void)sd_clear_oneshot_flag_in_file(bin_path);

	ledfasttoggle_with_speed(5, 200);
}

int main(void)
{
	int ret;
	bool led_state = true;

	// sys_flash_init();

	// sys_flash_read(0, DataBuffer, sizeof(DataBuffer));

	mount_sd_card();

	if (!gpio_is_ready_dt(&led))
	{
		return 0;
	}

	if (!gpio_is_ready_dt(&relay))
	{
		return 0;
	}

	if (!gpio_is_ready_dt(&auto_btn))
	{
		return 0;
	}

	if (!gpio_is_ready_dt(&manual_btn))
	{
		return 0;
	}

	ret = gpio_pin_configure_dt(&led, GPIO_OUTPUT_ACTIVE);
	if (ret < 0)
	{
		return 0;
	}

	ret = gpio_pin_configure_dt(&relay, GPIO_OUTPUT_ACTIVE);
	if (ret < 0)
	{
		return 0;
	}

	ret = gpio_pin_configure_dt(&auto_btn, GPIO_INPUT);
	if (ret < 0)
	{
		return 0;
	}

	ret = gpio_pin_configure_dt(&manual_btn, GPIO_INPUT);
	if (ret < 0)
	{
		return 0;
	}

	RTC_MCP = DEVICE_DT_GET_ONE(zephyr_rtcmcp7940);
	if (!device_is_ready(RTC_MCP))
	{
		LOG_ERR("RTC device not ready or not found");
	}

	SSD1306 = DEVICE_DT_GET_ONE(zephyr_ssd1306);
	if (!device_is_ready(SSD1306))
	{
		LOG_ERR("ssd1306 device not ready or not found");
	}

	ssd1306_DrawBitmap(SSD1306, 0, 0, startup_image_, 128, 64, White);
	ssd1306_UpdateScreen(SSD1306);
	k_msleep(3000);

	APPuart_init();

	/*
		RTCmcp7940_get_datetime(RTC_MCP, buffer);
		bool ok = pray2_sched_init_from_ram(&sched, DataBuffer, sizeof(DataBuffer), buffer);

		if (ok == true)
		{
			print_uart("\r\nPray2 Init success\r\n\r\n");
			int hh2, mm2, ss2, DD2, MM2, YYYY2;
			if (pray2_parse_rtc_ascii(buffer, &hh2, &mm2, &ss2, &DD2, &MM2, &YYYY2))
			{
				debug_print_month_any_year(DataBuffer, sizeof(DataBuffer), MM2);
			}
		}
		else
		{
			print_uart("\r\nPray2 Init failed\r\n");
		}
			*/

	load_pray2_from_sd_and_init();

	while (1)
	{

		manual_auto_config = gpio_pin_get_dt(&auto_btn);

		if (!manual_auto_config)
		{ /*Auto*/
			// gpio_pin_set(led.port, led.pin, 1);
			if (!auto_relay_once)
			{
				print_uart("auto config");
				auto_relay_once = 1;
				gpio_pin_set(relay.port, relay.pin, 1);
			}
		}
		else
		{ /*Manual*/

			// gpio_pin_set(led.port, led.pin, 0);
			auto_relay_once = 0;
			gpio_pin_set(relay.port, relay.pin, 0);
		}

		APPuart_process();

		RTCmcp7940_get_datetime(RTC_MCP, buffer);

		split_timestamp_HHMMSS_bar_DDMMYY(buffer, timebuff, sizeof(timebuff), datebuff, sizeof(datebuff));
		gpio_pin_toggle_dt(&led);
		int prayer;
		uint16_t onsec;
		if (pray2_sched_tick(&sched, buffer, &prayer, &onsec) && !manual_auto_config)
		{
			// prayer: 0=Fajr, 1=Dhuhr, 2=Asr, 3=Maghrib, 4=Isha
			gpio_pin_set(relay.port, relay.pin, 0);
			trigger_relay = 1;
			relay_start_time = k_uptime_get_32();

			char line[96];
			static const char *name[5] = {"Fajr", "Dhuhr", "Asr", "Maghrib", "Isha"};
			snprintf(line, sizeof(line), "Relay ON: %s for %us\r\n", name[prayer], (unsigned)onsec);
			print_uart(line);
		}

		if (trigger_relay)
		{
			if (k_uptime_get_32() - relay_start_time >= relay_timeout_set)
			{
				gpio_pin_set(relay.port, relay.pin, 1);
				trigger_relay = 0;
			}
		}

		ssd1306_Fill(SSD1306, Black);
		ssd1306_SetCursor(SSD1306, 0, 0);
		ssd1306_WriteString(SSD1306, timebuff, Font_16x24, White);
		ssd1306_SetCursor(SSD1306, 0, 34);
		ssd1306_WriteString(SSD1306, datebuff, Font_16x24, White);
		ssd1306_UpdateScreen(SSD1306);
	}
	return 0;
}
